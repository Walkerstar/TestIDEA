package mcw.test.leetcode.bzhan;

/**
 * 给你一个正整数数组 nums，你需要从中任选一些子集，然后将子集中每一个数乘以一个 任意整数，并求出他们的和。
 * <p>
 * 假如该和结果为 1，那么原数组就是一个「好数组」，则返回 True；否则请返回 False。
 * <p>
 * 示例 1：
 * <p>
 * 输入：nums = [12,5,7,23]
 * 输出：true
 * 解释：挑选数字 5 和 7。
 * 5*3 + 7*(-2) = 1
 * 示例 2：
 * <p>
 * 输入：nums = [29,6,10]
 * 输出：true
 * 解释：挑选数字 29, 6 和 10。
 * 29*1 + 6*(-3) + 10*(-1) = 1
 * 示例 3：
 * <p>
 * 输入：nums = [3,6]
 * 输出：false
 * <p>
 * 提示：
 * <p>
 * 1 <= nums.length <= 10^5
 * 1 <= nums[i] <= 10^9
 *
 * @author mcw 2023/2/15 11:28
 */
public class leetCode1250 {

    /**
     * 本题解涉及到数论中的「裴蜀定理」。
     *
     * 「裴蜀定理」的内容为：对于不全为零的任意整数 a 和 b，记 g=gcd(a,b)，其中 gcd(a,b) 为 a 和 b 的最大公约数，
     * 则对于任意整数 x 和 y 都满足 a × x + b × y 是 g 的倍数，特别地，存在整数 x 和 y 满足 a × x + b × y = g。
     *
     * 方法一：数论
     * 思路与算法
     *
     * 题目给出一个正整数数组 nums，现在我们需要从中任选一些子集，然后将子集中的每一个数都乘以一个任意整数并求出他们的和，如果该和的结果为 1，
     * 那么原数组就是一个「好数组」。现在我们需要判断数组 nums 是否是一个「好数组」。
     * 由「裴蜀定理」可得，题目等价于求 nums 中的全部数字的最大公约数是否等于 1，若等于 1 则原数组为「好数组」，否则不是。
     *
     * 求 nums 中全部数字的最大公约数的方法为，我们设初始为 x=nums[0]，然后对于每一个数 nums[i]，0 < i < n，我们更新 x = gcd(x,nums[i])。
     * 遍历完全部数字后，x 即为数组 nums 中全部的元素的最大公约数。然后判断其是否等于 1 即可。
     * 在实现过程中我们也可以进一步做优化：如果遍历过程中出现最大公约数等于 1 的情况，则由于 1 和任何正整数的最大公约数都是 1，此时可以提前结束遍历。
     */
    public boolean isGoodArray(int[] nums){
        int divisor=nums[0];
        for (int num : nums) {
            divisor=gcd(divisor,num);
            if (divisor==1){
                break;
            }
        }
        return divisor==1;
    }

    public int gcd(int a, int b) {
        return b != 0 ? gcd(b, a % b) : a;
    }
}
