package mcw.test.leetcode.bzhan;

/**
 * 神奇字符串 s 仅由 '1' 和 '2' 组成，并需要遵守下面的规则：
 * <p>
 * 神奇字符串 s 的神奇之处在于，串联字符串中 '1' 和 '2' 的连续出现次数可以生成该字符串。
 * s 的前几个元素是 s = "1221121221221121122……" 。
 * 如果将 s 中连续的若干 1 和 2 进行分组，可以得到 "1 22 11 2 1 22 1 22 11 2 11 22 ......" 。
 * 每组中 1 或者 2 的出现次数分别是 "1 2 2 1 1 2 1 2 2 1 2 2 ......" 。上面的出现次数正是 s 自身。
 * <p>
 * 给你一个整数 n ，返回在神奇字符串 s 的前 n 个数字中 1 的数目。
 *
 * @author mcw 2022/10/31 14:43
 */
public class leetCode481 {

    /**
     * 我们可以把 s 看成是由「1 组」和「2 组」交替组成的
     * 我们可以初始化字符串 s = 122，用指针 i 来指向现在需要构造的对应的组的大小，用指针 j 来指向现在需要构造的对应组的位置，
     * 此时 i = 2，j = 3。因为相邻组中的数字一定不会相同，所以我们可以通过 j 的前一个位置的数来判断当前需要填入的组中的数字。
     * 又因为每组的大小只为 1 或者 2，这保证了 j > i 在构造的过程中一定成立，即在指针 j 处填入组时一定能确定此时需要填入的组的大小。
     * 这样我们就可以不断往下进行构造直到字符串长度到达 n。
     */
    public int magicalString(int n) {
        if (n < 4) {
            return 1;
        }
        char[] s = new char[n];
        s[0] = '1';
        s[1] = '2';
        s[2] = '2';

        int res = 1;

        int i = 2;
        int j = 3;
        while (j < n) {
            // size 不是 1 就是 2
            int size = s[i] - '0';

            //在 j 位置处要输入的 数字，根据 ( j - 1 )处的数字判断，若是 1，则 j 处为 2；若是 2，则 j 处为 1。
            // 若 s[j-1]=1 ,则 num = 3 - ( '1'-'0') = 2 ; 若 s[j-1] = 2 ,则 num = 3 - ( '2'-'0') = 1
            int num = 3 - (s[j - 1] - '0');

            //构建对应的组
            while (size > 0 && j < n) {
                s[j] = (char) ('0' + num);
                if (num == 1) {
                    ++res;
                }
                ++j;
                --size;
            }
            ++i;
        }
        return res;
    }
}
